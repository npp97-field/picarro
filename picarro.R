# picarro.R
# R script to process Picarro instrument data
# Written under R 3.0.3
# Ben Bond-Lamberty May 2014

# This script processes data generated by the Picarro G2301 with 16-Port Distribution 
# Manifold. This setup generates a reading every second or so, switching between samples 
# (recorded in the solenoid_valves field). This produces a lot of data. The script reads
# all data files in a particular directory, summarizing them and producing a single
# summary output file. (Also, optionally, a single raw output file.)

# To use:
# 	1. Set SYSTEM_VOLUME and CHAMBER_AREA variables below
#	2. Set MEAS_INTERVAL variable
#	3. If using plot-specific ancillary data, set PLOTDATA variable
#			and make sure file is in correct format
#	4. Set INPUT_DIR to location of analyzer output files
#	5. Check the flux calculations in compute_flux() for your use case
#	6. source() this file.
#			start with a simple test case, and carefully check log file and outputs!

# Important variable definitions, esp. data source & destination
SCRIPTNAME		<- "picarro.R"
#INPUT_DIR		<- "sampledata/"
INPUT_DIR <- "~/Documents/Work/Current/Bailey\ SFA/DWP\ experiment/Data/Data\ from\ Sarah"
OUTPUT_DIR		<- "outputs/"
LOG_DIR			<- "logs/"

# The optional VALVEDATA file maps solenoid valves to cores, by e.g.
# treatment and rep. It *must* have a 'solenoid_valves' field to be merged correctly
VALVEDATA	<- "sampledata/valve_data.csv"

# The optional COREDATA file holds information about the cores
# To be merged correctly, it must have the same field name (e.g. 'corenum') as
# the solenoid data file. 
# It *may* have 'Mass' and/or 'Area' fields, which will be divided into the computed flux
#	- if present, the 'Area' field will override CHAMBER_AREA below
# It *may* have a 'Volume' field, cm3, which will be added to SYSTEM_VOLUME for each plot
COREDATA 		<- "sampledata/core_data.csv"

# Picarros output a ton of data. For testing, we may want to subsample
# e.g. 0.01 = sample 1%. Set SUBSAMPLE_FRACTION to 1 for no subsampling
SUBSAMPLE_FRACTION	<- 0.01
RANDOM_SEED			<- 12345		# comment out to not set seed

SYSTEM_VOLUME	<- 15.15 / 100^3		# m^3
CHAMBER_AREA	<- 5.5					# cm^2

SEPARATOR		<- "-------------------"


# -----------------------------------------------------------------------------
# Time-stamped output function
printlog <- function( msg="", ..., ts=TRUE, cr=TRUE ) {
	if( ts ) cat( date(), " " )
	cat( msg, ... )
	if( cr ) cat( "\n")
} # printlog

# -----------------------------------------------------------------------------
# Print dimensions of data frame
printdims <- function( d, dname=deparse( substitute( d ) ) ) {
	stopifnot( is.data.frame( d ) )
	printlog( dname, "rows =", nrow( d ), "cols =", ncol( d ) )
} # printdims

# -----------------------------------------------------------------------------
# Save a ggplot figure
saveplot <- function( pname, p=last_plot(), ptype=".pdf" ) {
	stopifnot( file.exists( OUTPUT_DIR ) )
	fn <- paste0( OUTPUT_DIR, "/", pname, ptype )
	printlog( "Saving", fn )
	ggsave( fn, p )
} # saveplot

# -----------------------------------------------------------------------------
# Save a data frame
savedata <- function( df, extension=".csv" ) {
	stopifnot( file.exists( OUTPUT_DIR ) )
	fn <- paste0( OUTPUT_DIR, "/", deparse( substitute( df ) ), extension )
	printlog( "Saving", fn )
	write.csv( df, fn, row.names=F )
} # savedata

# -----------------------------------------------------------------------------
# Open a csv file and return data
read_csv <- function( fn, datadir=".", ... ) {
	fqfn <- paste( normalizePath( datadir ), fn, sep="/" )
	printlog( "Opening", fqfn )
	stopifnot( file.exists( fqfn ) )
	read.csv( fqfn, stringsAsFactors=F, ... )
} # read_csv

# -----------------------------------------------------------------------------
# Load requested libraries
loadlibs <- function( liblist ) {
	printlog( "Loading libraries..." )
	loadedlibs <- vector()
	for( lib in liblist ) {
		printlog( "Loading", lib )
		loadedlibs[ lib ] <- require( lib, character.only=T )
		if( !loadedlibs[ lib ] )
			warning( "this package is not installed!" )
	}
	invisible( loadedlibs )
} # loadlibs

# -----------------------------------------------------------------------------
# read a single output file, returning data frame
read_outputfile <- function( fn ) {
	fqfn <- paste( INPUT_DIR, fn, sep="/" )
	printlog( "Reading", fn )
	stopifnot( file.exists( fqfn ) )
	d <- read.table( fqfn, header=T )
	printdims( d )

	# Add ancillary data
	d$file <- basename( fn )
	d$dir <- dirname( fn )
	
	return( d )
} # read_outputfile

# -----------------------------------------------------------------------------
# scan a directory and process all files in it, returning tempfile names
process_directory <- function( path=INPUT_DIR ) {
	samplenum <- 0
	tf <- tempfile()
	printlog( "raw tempfile is", tf )
	stf <- tempfile()
	printlog( "summary tempfile is", tf )
	filelist <- list.files( path=path, pattern="dat$", recursive=T )
	for( f in 1:length( filelist ) ) {
		printlog( SEPARATOR )
		printlog( "Processing file", f, "of", length( filelist ) )
		d <- read_outputfile( filelist[ f ] )

		printlog( "Assigning sample numbers..." )  
		samplenum <- samplenum + 1
		d[ 1, "samplenum" ] <- samplenum
		for( i in 2:nrow( d ) ) { 	# couldn't think of a 1-liner to do this
			if( d[ i, "solenoid_valves" ] != d[ i-1, "solenoid_valves" ] ) {
				samplenum <- samplenum + 1
			} 
			d[ i, "samplenum" ] <- samplenum
		}
		
		printlog( "Computing summary statistics for each sample..." )
		# Note that if a sampling is split across two files, this will produce
		# two different summaries. We assume this is inconsequential.
		d$ELAPSED_TIME <- ( d$EPOCH_TIME - min( d$EPOCH_TIME ) ) / 60.0
		d1 <- ddply( d, .( samplenum ), summarise,
			TIME_LEN_MIN 		= max( ELAPSED_TIME ) - min( ELAPSED_TIME ),
			EPOCH_TIME			= mean( EPOCH_TIME ),
			ALARM_STATUS		= mean( ALARM_STATUS ),
			INST_STATUS			= mean( INST_STATUS ),
			N 					= length( ELAPSED_TIME ),
			solenoid_valves		= mean( solenoid_valves ),
			mCH4_dry			= lm( CH4_dry ~ ELAPSED_TIME )$coefficients[ 2 ],
			mCO2_dry			= lm( CO2_dry ~ ELAPSED_TIME )$coefficients[ 2 ],
			CH4_dry_min			= min( CH4_dry ),
			CO2_dry_min 		= min( CO2_dry ),
			h2o_reported_min 	= min( h2o_reported ),
			CH4_dry_max			= max( CH4_dry ),
			CO2_dry_max 		= max( CO2_dry ),
			h2o_reported_max 	= max( h2o_reported ),
			CH4_dry_sd			= sd( CH4_dry ),
			CO2_dry_sd 			= sd( CO2_dry ),
			h2o_reported_sd 	= sd( h2o_reported ),
			CH4_dry 			= mean( CH4_dry ),
			CO2_dry 			= mean( CO2_dry ),
			h2o_reported 		= mean( h2o_reported )
			)
		d$ELAPSED_TIME <- NULL
		d1$file <- basename( filelist[ f ] )
		d1$dir <- dirname( filelist[ f ] )

		printdims( d1 )
		write.table( d1, stf, row.names=F, append=( f>1 ), col.names=( f==1 ), sep="," )

		if( SUBSAMPLE_FRACTION < 1 ) {
			printlog( "Subsampling at", SUBSAMPLE_FRACTION, "..." )
			d <- d[ sample( nrow( d ), nrow( d ) * SUBSAMPLE_FRACTION ), ]
			printdims( d )
		}
	
		write.table( d, tf, row.names=F, append=( f>1 ), col.names=( f==1 ), sep="," )
	}
	list( tf=tf, stf=stf )
}

# -----------------------------------------------------------------------------
# compute fluxes
compute_flux <- function( d ) {
	stop( 'compute_flux not used/working yet' )
	m <- lm( CO2_Ref ~ Sec, data=d )
	resp_raw <- as.numeric( coef( m )[ 2 ] )	# i.e. the slope
	
	# We want to convert raw respiration (d[CO2]/dt) to a flux using
	# A = dC/dt * V/S * Pa/RT (e.g. Steduto et al. 2002), where
	# 	A is CO2 flux (umol/m2/s)
	#	dC/dt is raw respiration as above (mole fraction/s)
	# 	V is total chamber volume (m3)
	#		...correcting for varying headspaces in the cores, if applicable
	#	S is ground surface area (m2), if applicable
	# 	M is sample dry mass (g), if applicable
	#	Pa is atmospheric pressure (kPa)
	#	R is universal gas constant (8.3 x 10-3 m-3 kPa mol-1 K-1)
	#	T is air temperature (K)

	S 			<- CHAMBER_AREA		# note cm2, not m2!
	if( any( names( d )=="Area" ) ) {
		 S <- mean( d$Area )
	}
	V 			<- SYSTEM_VOLUME
	if( any( names( d )=="Volume" ) ) {
		V <- V + mean( d$Volume )
	}
	M 			<- 1.0
	if( any( names( d )=="Mass" ) ) {
		 M <- mean( d$Mass )
	}
	
	Pa 			<- 101						# kPa
	R 			<- 8.3e-3					# m-3 kPa mol-1 K-1
	
	# Calculate mass- (or area-) corrected respiration, umol/g soil/s or umol/cm2/s
	resp_corrected <- resp_raw * V/S/M * Pa/( R*( 273.1+Tair ) )

	# Convert from umol/g soil/s to mgC/kg soil/day or whatever
	# NOTE: you probably want to change this line for your specific setup
	flux <- resp_corrected / 1e6 * 12 * 1000 * 1000 * 60 * 60 * 24
	return( c( Tair=Tair, V=V, S=S, Day=mean( d$Day ), Month=mean( d$Month ), N=nrow( d ), flux=flux ) )
}


# ==============================================================================
# 										Main
# ==============================================================================

INPUT_DIR <- normalizePath( INPUT_DIR )
OUTPUT_DIR <- normalizePath( OUTPUT_DIR )
if( !file.exists( OUTPUT_DIR ) ) {
	printlog( "Creating", OUTPUT_DIR )
	dir.create( OUTPUT_DIR )
}
LOG_DIR <- normalizePath( LOG_DIR )
if( !file.exists( LOG_DIR ) ) {
	printlog( "Creating", LOG_DIR )
	dir.create( LOG_DIR )
}

sink( paste0( LOG_DIR, SCRIPTNAME, ".txt" ), split=T )

printlog( "Welcome to", SCRIPTNAME )

if( exists( "RANDOM_SEED" ) ) {
	printlog( "Setting random generator seed to", RANDOM_SEED )
	set.seed( RANDOM_SEED )
}

loadlibs( c( "ggplot2", "reshape2", "plyr", "lubridate" ) )	# the hadleyverse
theme_set( theme_bw() )

# -----------------------------------------------------------------------------
# Initial processing steps - should be applicable to all Picarro setups

tempfiles <- process_directory()
printlog( SEPARATOR )
printlog( "All done. Reading raw data back in..." )
rawdata <- read.csv( tempfiles[[ 'tf' ]] )
printdims( rawdata )
printlog( "All done. Reading summarized data back in..." )
summarydata <- read.csv( tempfiles[[ 'stf' ]] )
printdims( summarydata )
printlog( "Removing NAs..." )
summarydata <- na.omit( summarydata )
printdims( summarydata )

# Fractional solenoid values mean that the analyzer was shifting
# between two samples. Discard these.
printlog( "Removing fractional solenoid_valves" )
rawdata <- subset( rawdata, solenoid_valves==trunc( solenoid_valves ) )
summarydata <- subset( summarydata, solenoid_valves==trunc( solenoid_valves ) )
printdims( rawdata )

# Make true dates
# TODO: use this information!
printlog( "Converting date/time info to POSIXct..." )
rawdata$DATETIME <- ymd_hms( paste( rawdata$DATE, rawdata$TIME ) )

# -----------------------------------------------------------------------------
# This step makes some assumptions about data setup to assign 'treatment' and 'rep'

printlog( "** NOTE **" )
printlog( "** Here this script assumes data are stored in a particular way" )
printlog( "** We assume first folder level of path contains treatment info," )
printlog( "** the second is a rep, and there are exactly two levels." )
printlog( "**  i.e. {INPUT_DIR}/treatmentname/repnum/{files}" )
printlog( "** This is very specific to a particular setup-change as necessary." )
printlog( "Splitting file path data..." )
rawdata <- cbind( rawdata, colsplit( rawdata$dir, "/", names=c( "treatment", "rep" ) ) )
summarydata <- cbind( summarydata, colsplit( summarydata$dir, "/", names=c( "treatment", "rep" ) ) )

# -----------------------------------------------------------------------------
# Merge data with ancillary data about valve assignment and core info

# Merge data with 'valvedata' that describe assignment of valves to cores
if( any( names( rawdata )=="solenoid_valves" ) & exists( 'VALVEDATA' ) ) {
	sv <- read_csv( VALVEDATA, comment.char="#" )
	printlog( "Merging Picarro and solenoid_valves data..." )
	rawdata <- merge( rawdata, sv )
	summarydata <- merge( summarydata, sv )
}

# Merge data with 'coredata' that describe each core
# The valvedata step above presumably merged a core number that's now used in this merge
if( exists( 'COREDATA' ) ) {
	coredata <- read_csv( COREDATA, comment.char="#" )
	coredata$DepthRange <- factor( coredata$DepthRange, levels=c( "0-30", "30-60", "60-90",
		"90-120", "120-150", "150-180", "180-210", "210-240" ) )
	printlog( "Merging Picarro and core data..." )
	rawdata <- merge( rawdata, coredata )
	summarydata <- merge( summarydata, coredata )
}

# -----------------------------------------------------------------------------
# Outlier handling

	# TODO: identify outliers algorithmically, identify, save
	
	printlog( "Getting rid of crazy values..." )
	rawdata <- rawdata[ rawdata$CH4_dry < 5, ]
	summarydata <- summarydata[ summarydata$CH4_dry < 5, ]
	printdims( rawdata )
	printdims( summarydata )
	
	printlog( "Focusing on 'real' cores only..." )
	rawdata <- rawdata[ !is.na( rawdata$corenum ), ]
	summarydata <- summarydata[ !is.na( summarydata$corenum ), ]
	printdims( rawdata )
	printdims( summarydata )

# -----------------------------------------------------------------------------
# Compute the time since a particular treatment/rep combination started

printlog( "Computing time elapsed" )
rawdata <- rawdata[ order( rawdata[ 'EPOCH_TIME' ] ), ]
rawdata <- ddply( rawdata, .( treatment, rep ), mutate, ELAPSED_MINUTES=( EPOCH_TIME-EPOCH_TIME[ 1 ] )/60, .progress="text" )
summarydata <- summarydata[ order( summarydata[ 'EPOCH_TIME' ] ), ]
summarydata <- ddply( summarydata, .( treatment, rep ), mutate, ELAPSED_MINUTES=( EPOCH_TIME-EPOCH_TIME[ 1 ] )/60, .progress="text" )


# -----------------------------------------------------------------------------
# Summary figures

rawdata$corenum <- as.factor( rawdata$corenum )
summarydata$corenum <- as.factor( summarydata$corenum )
print( summary( rawdata ) )

p_ch4 <- ggplot( rawdata, aes( ELAPSED_MINUTES, CH4_dry, color=rep ) ) + geom_point()
p_ch4 <- p_ch4 + facet_grid( treatment~., scales="free" )
print( p_ch4 )
saveplot( "raw_ch4_allreps" )
print( p_ch4 %+% summarydata )
saveplot( "summary_ch4_allreps" )


p_co2 <- ggplot( rawdata, aes( ELAPSED_MINUTES, CO2_dry, color=rep ) ) + geom_point()
p_co2 <- p_co2 + facet_grid( treatment~., scales="free" )
print( p_co2 )
saveplot( "raw_co2_allreps" )
print( p_co2 %+% summarydata )
saveplot( "summary_co2_allreps" )


	# TEMPORARY
	
	printlog( "Focusing on rep 1 only..." )
	rawdata1 <- rawdata[ rawdata$rep=="Rep 1", ]
	summarydata1 <- summarydata[ summarydata$rep=="Rep 1", ]


	p_ch4r1 <- qplot( ELAPSED_MINUTES, CH4_dry, data=rawdata1, geom="line", group=1, size=I( 2 ), color=corenum )
	p_ch4r1 <- p_ch4r1 + facet_grid( treatment~., scales="free" )
	print( p_ch4r1 )
	saveplot( "raw_ch4_rep1" )
	print( p_ch4r1 %+% summarydata1 )
	saveplot( "summary_ch4_rep1" )

	p_co2r1 <- qplot( ELAPSED_MINUTES, CO2_dry, data=rawdata1, geom="line", group=1, size=I( 2 ), color=corenum )
	p_co2r1 <- p_co2r1 + facet_grid( treatment~., scales="free" ) 
	print( p_co2r1 )
	saveplot( "raw_co2_rep1" )
	print( p_co2r1 %+% summarydata1 )
	saveplot( "summary_co2_rep1" )
	saveplot( "raw_ch4_rep1_closeup", p_ch4r1 + xlim( c( 1100,1180 ) ) )

	summarydata1_m <- melt( summarydata1, measure.vars=c( 'CH4_dry','CO2_dry' ) )
	p_ch4co2r1 <- qplot( ELAPSED_MINUTES, value, data=subset( summarydata1_m, treatment=="Injection 1" ), geom="line", group=1, size=I( 2 ), color=corenum )
	p_ch4co2r1 <- p_ch4co2r1 + facet_grid( variable~., scales="free" ) 
	p_ch4co2r1 <- p_ch4co2r1 + ggtitle( "Injection 1" )
	print( p_ch4co2r1 )
	saveplot( "summary_ch4co2_rep1_inj1" )
	p_ch4co2r1 <- qplot( ELAPSED_MINUTES, value, data=subset( summarydata1_m, treatment=="Injection 2" ), geom="line", group=1, size=I( 2 ), color=corenum )
	p_ch4co2r1 <- p_ch4co2r1 + facet_grid( variable~., scales="free" ) 
	p_ch4co2r1 <- p_ch4co2r1 + ggtitle( "Injection 2" )
	print( p_ch4co2r1 )
	saveplot( "summary_ch4co2_rep1_inj2" )




# Look at slopes of individual measurement periods...
summarydata[ which( abs( summarydata$mCH4_dry ) > 0.05 ), "mCH4_dry" ] <- NA

summarydata_m <- melt( summarydata, measure.vars=c( 'mCH4_dry','mCO2_dry' ) )

p1 <- qplot( ELAPSED_MINUTES, value, color=rep, data=subset( summarydata_m, treatment=="Injection 1" ), geom='line' )
p1 <- p1 + facet_grid( variable~DepthRange, scales='free_y' )
p1 <- p1 + ggtitle( "Injection 1" )
print( p1 )
saveplot( "summary_mCH4CO2_inj1" )

p2 <- p1 %+% subset( summarydata_m, treatment=="Injection 2" )
p2 <- p2 + ggtitle( "Injection 2" )
print( p2 )
saveplot( "summary_mCH4CO2_inj2" )

#print( p_co2r1 + xlim( c( 1000,1080 ) ) )
#saveplot( "summary_co2_rep1_closeup" )

# -----------------------------------------------------------------------------
# All done

savedata( rawdata )
savedata( summarydata )

printlog( "All done with", SCRIPTNAME )
print( sessionInfo() )
sink()
